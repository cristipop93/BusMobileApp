    @Deprecated
    public Interpreter(@NonNull MappedByteBuffer mappedByteBuffer) {
        this((ByteBuffer)mappedByteBuffer, (Interpreter.Options)null);
    }

    public Interpreter(@NonNull ByteBuffer byteBuffer, Interpreter.Options options) {
        this.wrapper = new NativeInterpreterWrapper(byteBuffer, options);
    }

    public void run(@NonNull Object input, @NonNull Object output) {
        Object[] inputs = new Object[]{input};
        Map<Integer, Object> outputs = new HashMap();
        outputs.put(0, output);
        this.runForMultipleInputsOutputs(inputs, outputs);
    }

    public void runForMultipleInputsOutputs(Object[] inputs, @NonNull Map<Integer, Object> outputs) {
        this.checkNotClosed();
        this.wrapper.run(inputs, outputs);
    }



-----------------------------------------

    void run(Object[] inputs, Map<Integer, Object> outputs) {
        this.inferenceDurationNanoseconds = -1L;
        if (inputs != null && inputs.length != 0) {
            if (outputs != null && !outputs.isEmpty()) {
                for(int i = 0; i < inputs.length; ++i) {
                    Tensor tensor = this.getInputTensor(i);
                    int[] newShape = tensor.getInputShapeIfDifferent(inputs[i]);
                    if (newShape != null) {
                        this.resizeInput(i, newShape);
                    }
                }

                boolean needsAllocation = !this.isMemoryAllocated;
                if (needsAllocation) {
                    allocateTensors(this.interpreterHandle, this.errorHandle);
                    this.isMemoryAllocated = true;
                }

                for(int i = 0; i < inputs.length; ++i) {
                    this.getInputTensor(i).setTo(inputs[i]);
                }

                long inferenceStartNanos = System.nanoTime();
                run(this.interpreterHandle, this.errorHandle);
                long inferenceDurationNanoseconds = System.nanoTime() - inferenceStartNanos;
                if (needsAllocation) {
                    for(int i = 0; i < this.outputTensors.length; ++i) {
                        if (this.outputTensors[i] != null) {
                            this.outputTensors[i].refreshShape();
                        }
                    }
                }

                Iterator var13 = outputs.entrySet().iterator();

                while(var13.hasNext()) {
                    Entry<Integer, Object> output = (Entry)var13.next();
                    this.getOutputTensor((Integer)output.getKey()).copyTo(output.getValue());
                }

                this.inferenceDurationNanoseconds = inferenceDurationNanoseconds;
            } else {
                throw new IllegalArgumentException("Input error: Outputs should not be null or empty.");
            }
        } else {
            throw new IllegalArgumentException("Input error: Inputs should not be null or empty.");
        }
    }


----------------------------------
    void setTo(Object src) {
        this.throwExceptionIfTypeIsIncompatible(src);
        if (!isByteBuffer(src)) {
            writeMultiDimensionalArray(this.nativeHandle, src);
        } else {
            ByteBuffer srcBuffer = (ByteBuffer)src;
            if (srcBuffer.isDirect() && srcBuffer.order() == ByteOrder.nativeOrder()) {
                writeDirectBuffer(this.nativeHandle, srcBuffer);
            } else {
                this.buffer().put(srcBuffer);
            }

        }
    }



-------------------------------------------
    private void throwExceptionIfTypeIsIncompatible(Object o) {
        if (isByteBuffer(o)) {
            ByteBuffer oBuffer = (ByteBuffer)o;
            if (oBuffer.capacity() != this.numBytes()) {
                throw new IllegalArgumentException(String.format("Cannot convert between a TensorFlowLite buffer with %d bytes and a ByteBuffer with %d bytes.", this.numBytes(), oBuffer.capacity()));
            }
        } else {
            DataType oType = dataTypeOf(o);
            if (oType != this.dtype) {
                throw new IllegalArgumentException(String.format("Cannot convert between a TensorFlowLite tensor with type %s and a Java object of type %s (which is compatible with the TensorFlowLite type %s).", this.dtype, o.getClass().getName(), oType));
            } else {
                int[] oShape = computeShapeOf(o);
                if (!Arrays.equals(oShape, this.shapeCopy)) {
                    throw new IllegalArgumentException(String.format("Cannot copy between a TensorFlowLite tensor with shape %s and a Java object with shape %s.", Arrays.toString(this.shapeCopy), Arrays.toString(oShape)));
                }
            }
        }
    }


-----------------------------------
    static DataType dataTypeOf(Object o) {
        if (o != null) {
            Class c;
            for(c = o.getClass(); c.isArray(); c = c.getComponentType()) {
            }

            if (Float.TYPE.equals(c)) {
                return DataType.FLOAT32;
            }

            if (Integer.TYPE.equals(c)) {
                return DataType.INT32;
            }

            if (Byte.TYPE.equals(c)) {
                return DataType.UINT8;
            }

            if (Long.TYPE.equals(c)) {
                return DataType.INT64;
            }

            if (String.class.equals(c)) {
                return DataType.STRING;
            }
        }

        throw new IllegalArgumentException("DataType error: cannot resolve DataType of " + o.getClass().getName());
    }




